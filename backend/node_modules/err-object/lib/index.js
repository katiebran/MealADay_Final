'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

const util = require('util');

const error = module.exports = (thing, Ctor = Error) => {
  if (typeof thing === 'string') {
    return new Ctor(thing);
  }

  const {
    message
  } = thing,
        options = _objectWithoutProperties(thing, ['message']);

  const error = new Ctor(message);
  Object.assign(error, options);
  return error;
};

const _factory = (e, code, preset, ...args) => {
  const {
    ctor = Error,
    message: messageTemplate
  } = preset,
        others = _objectWithoutProperties(preset, ['ctor', 'message']);

  const message = typeof messageTemplate === 'function' ? messageTemplate(...args) : util.format(e(messageTemplate), ...args);

  return error(_extends({}, others, {
    code,
    message
  }), ctor);
};

const _notDefined = (code, message = '') => error({
  code,
  message
});

const checkFunction = (subject, name) => {
  if (typeof subject !== 'function') {
    throw error(`${name} must be a function`, TypeError);
  }
};

const _KEY_I18N = 'err-object:i18n';
const KEY_I18N = typeof Symbol === 'undefined' ? _KEY_I18N : Symbol(_KEY_I18N);

error.Errors = class {
  constructor({
    factory,
    notDefined
  } = {}) {
    this._errors = Object.create(null);
    this.E = this.E.bind(this);
    this.error = this.error.bind(this);
    this.i18n = this.i18n.bind(this);
    this[KEY_I18N] = this[KEY_I18N].bind(this);
    this._factory = factory || _factory;
    this._notDefined = notDefined || _notDefined;
    this._language = null;

    checkFunction(this._factory, 'factory');
    checkFunction(this._notDefined, 'notDefined');
  }

  [KEY_I18N](x) {
    return this._language && this._language[x] || x;
  }

  i18n(language) {
    this._language = language;
    return this;
  }

  E(code, preset = {}, factory) {
    factory = factory || this._factory;

    checkFunction(factory, 'factory');

    this._errors[code] = [preset, factory];
    return this;
  }

  error(code, ...args) {
    if (code in this._errors) {
      const [preset, factory] = this._errors[code];
      return factory(this[KEY_I18N], code, preset, ...args);
    }

    return this._notDefined(code, ...args);
  }
};
