'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Layer = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _layer = require('./layer');

var _layer2 = _interopRequireDefault(_layer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.Layer = _layer2.default;


const isUnset = value => value === undefined || value === null;
const alwaysNoFound = () => true;

class LayeredCache {
  constructor(layers, {
    isNotFound = isUnset
  } = {}) {

    this._layers = layers.map(layer => new _layer2.default(layer));
    this._length = this._layers.length;
    this._isNotFound = isNotFound;
  }

  depth() {
    return this._length;
  }

  layer(n) {
    return n < 0 ? this._layers[this._length + n] : this._layers[n];
  }

  msync(...keys) {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const values = yield _this.layer(-1).mget(...keys);
      const pairs = [];
      values.forEach(function (value, i) {
        if (_this._isNotFound(value)) {
          return;
        }

        pairs.push([keys[i], value]);
      });

      const tasks = _this._layers.slice(0, -1).map(function (layer) {
        return layer.mset(...pairs);
      });

      yield _promise2.default.all(tasks);
      return values;
    })();
  }

  // Sync
  sync(key) {
    return this.msync(key).then(values => values[0]);
  }

  mget(...keys) {
    var _this2 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      if (!keys.length) {
        return [];
      }

      const tasks = [];
      const values = yield _this2._traverseGet(0, keys, tasks);

      if (tasks.length) {
        yield _promise2.default.all(tasks);
      }

      return values;
    })();
  }

  get(key) {
    return this.mget(key).then(values => values[0]);
  }

  // Recursively read cached values
  // or deep down to lower cache layer if there is at least a key is not cached.
  // @param {Array<Promise>} tasks Array of set tasks of the previous job.
  _traverseGet(index, keys, tasks) {
    var _this3 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const layer = _this3._layers[index];
      const values = yield layer.mget(...keys);

      if (++index >= _this3._length) {
        return values;
      }

      const keyIndexes = [];
      const keysOfMissedValues = values.reduce(function (missed, value, i) {
        if (_this3._isNotFound(value)) {
          keyIndexes.push(i);
          missed.push(keys[i]);
        }

        return missed;
      }, []);

      if (!keysOfMissedValues.length) {
        return values;
      }

      const valuesFromLowerLayer = yield _this3._traverseGet(index, keysOfMissedValues, tasks);

      const keyValuePairsToSet = [];
      valuesFromLowerLayer.forEach(function (value, i) {
        if (_this3._isNotFound(value)) {
          return;
        }

        // Update old values
        values[keyIndexes[i]] = value;
        const key = keysOfMissedValues[i];
        keyValuePairsToSet.push([key, value]);
      });

      if (keyValuePairsToSet.length) {
        // Update the cache of the current layer
        tasks.push(layer.mset(...keyValuePairsToSet));
      }

      return values;
    })();
  }

  _forEach(fn) {
    return _promise2.default.all(this._layers.map(fn));
  }

  set(key, value) {
    return this._forEach(layer => layer.set(key, value));
  }

  mset(...pairs) {
    return this._forEach(layer => layer.mset(...pairs));
  }
}
exports.default = LayeredCache;