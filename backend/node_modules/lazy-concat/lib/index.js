'use strict';

const find = (equal, max, array, item) => {

  let i = array.length;
  max = i - max - 1;

  while (i-- && i > max) {
    if (equal(array[i], item)) {
      return i;
    }
  }

  return -1;
};

const isNullOrUndefined = x => x === undefined || x === null;

const APConcat = Array.prototype.concat;
const strictEqual = (a, b) => a === b;

const run = (equal, ...items) => {
  return items.reduce((prev, current, i) => {
    if (i === 1) {
      if (isNullOrUndefined(prev)) {
        return APConcat.call(prev, current);
      }

      if (!Array.isArray(prev)) {
        // Actually, `APConcat.call(1, 2)` -> `[Object(1), 2]`
        // but this behavior is really weird and error-prone,
        // so `lazyConat(1, 2)` will be `[1, 2]`
        prev = [prev];
      }
    }

    const isArray = Array.isArray(current);
    const item = isArray ? current[0] : current;
    const max = isArray ? current.length : 1;

    const index = find(equal, max, prev, item);
    return ~index ? APConcat.call(prev.slice(0, index), current) : APConcat.call(prev, current);
  });
};

const factory = ({ equal = strictEqual } = {}) => {
  return (...items) => run(equal, ...items);
};

const concat = factory();
concat.factory = factory;

module.exports = concat;
