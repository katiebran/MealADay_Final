'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

const util = require('util');

const error = module.exports = function (thing) {
  let Ctor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Error;

  if (typeof thing === 'string') {
    return new Ctor(thing);
  }

  const message = thing.message,
        others = _objectWithoutProperties(thing, ['message']);

  const error = new Ctor(message);
  Object.assign(error, others);
  return error;
};

const _factory = function (e, code, preset) {
  for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
    args[_key - 3] = arguments[_key];
  }

  var _preset$ctor = preset.ctor;

  const ctor = _preset$ctor === undefined ? Error : _preset$ctor,
        messageTemplate = preset.message,
        others = _objectWithoutProperties(preset, ['ctor', 'message']);

  const message = typeof messageTemplate === 'function' ? messageTemplate.apply(undefined, args) : util.format.apply(util, [e(messageTemplate)].concat(args));

  return error(_extends({}, others, {
    code,
    message,
    args
  }), ctor);
};

const _notDefined = function (code) {
  let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return error({
    code,
    message
  });
};

const checkFunction = (subject, name) => {
  if (typeof subject !== 'function') {
    throw error(`${name} must be a function`, TypeError);
  }
};

const _KEY_I18N = 'err-object:i18n';
const KEY_I18N = typeof Symbol === 'undefined' ? _KEY_I18N : Symbol(_KEY_I18N);

error.Errors = class {
  constructor() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    let factory = _ref.factory,
        notDefined = _ref.notDefined;

    this._errors = Object.create(null);
    this.E = this.E.bind(this);
    this.error = this.error.bind(this);
    this.i18n = this.i18n.bind(this);
    this._factory = factory || _factory;
    this._notDefined = notDefined || _notDefined;
    this._language = null;

    checkFunction(this._factory, 'factory');
    checkFunction(this._notDefined, 'notDefined');
  }

  [KEY_I18N](x) {
    return x;
  }

  i18n(__) {
    this[KEY_I18N] = __;
    return this;
  }

  E(code) {
    let preset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let factory = arguments[2];

    factory = factory || this._factory;

    checkFunction(factory, 'factory');

    this._errors[code] = [preset, factory];
    return this;
  }

  error(code) {
    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    if (code in this._errors) {
      var _errors$code = _slicedToArray(this._errors[code], 2);

      const preset = _errors$code[0],
            factory = _errors$code[1];

      return factory.apply(undefined, [this[KEY_I18N], code, preset].concat(args));
    }

    return this._notDefined.apply(this, [code].concat(args));
  }
};
