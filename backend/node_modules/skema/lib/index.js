'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

module.exports = skema;

var _require = require('promise.extra'),
    series = _require.series,
    waterfall = _require.waterfall;

var forEach = require('lodash.foreach');
var Type = require('./type');

var _require2 = require('./util'),
    merge = _require2.merge,
    reject = _require2.reject,
    isFunction = _require2.isFunction,
    isRegExp = _require2.isRegExp;

var _require3 = require('./error'),
    i18n = _require3.i18n;

var Skema = function () {
  function Skema(_ref) {
    var _ref$rules = _ref.rules,
        rules = _ref$rules === undefined ? {} : _ref$rules,
        types = _ref.types,
        _ref$clean = _ref.clean,
        clean = _ref$clean === undefined ? false : _ref$clean,
        _ref$parallel = _ref.parallel,
        parallel = _ref$parallel === undefined ? true : _ref$parallel;

    _classCallCheck(this, Skema);

    this._rules = {};
    this._type = new Type(types);
    this._clean = clean;
    this._parallel = parallel;

    var name = void 0;
    for (name in rules) {
      this.add(name, rules[name]);
    }
  }

  _createClass(Skema, [{
    key: 'add',
    value: function add(name, rule) {
      if (!('type' in rule)) {
        return this._add(name, rule, {});
      }

      var type = this._type.get(rule.type);
      if (!type) {
        throw new Error('unknown type of "' + rule.type + '" for "' + name + '".');
      }

      return this._add(name, rule, type);
    }
  }, {
    key: '_add',
    value: function _add(name, rule, type) {
      var _rule$configurable = rule.configurable,
          configurable = _rule$configurable === undefined ? true : _rule$configurable,
          _rule$enumerable = rule.enumerable,
          enumerable = _rule$enumerable === undefined ? true : _rule$enumerable,
          _rule$writable = rule.writable,
          writable = _rule$writable === undefined ? true : _rule$writable;


      var cleaned = {
        configurable: configurable,
        enumerable: enumerable,
        writable: writable
      };

      if (isFunction(rule.when)) {
        cleaned.when = rule.when;
      }

      // User will override default setter
      var default_setter = 'default' in rule ? rule.default : type.default;

      if (default_setter) {
        cleaned.default = isFunction(default_setter) ? default_setter : function () {
          return default_setter;
        };
      }

      var setters = merge(type.set, rule.set, function (setter) {
        if (!isFunction(setter)) {
          throw new Error('invalid setter for "' + name + '".');
        }

        return setter;
      });

      if (setters.length) {
        cleaned.set = setters;
      }

      var validators = merge(type.validate, rule.validate, function (validator) {
        validator = parse_validator(validator);
        if (!validator) {
          throw new Error('invalid validator for "name", only functions and regular expressions are accepted.');
        }

        return validator;
      });

      if (validators.length) {
        cleaned.validate = validators;
      }

      this._rules[name] = cleaned;

      return this;
    }
  }, {
    key: 'register',
    value: function register(type, property) {
      this._type.register(type, property);
      return this;
    }
  }, {
    key: 'parse',
    value: function parse(data) {
      var _this = this;

      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var values = this._clean ? Object.create(null) : simpleClone(data);

      var parallel = this._parallel;

      var context = simpleClone(data);
      var tasks = Object.keys(this._rules).map(function (key) {
        return function () {
          return _this._parse(key, data[key], data, context, args).then(function (value) {
            if (!parallel) {
              context[key] = value;
            }

            define_property(values, key, value, _this._rules[key]);
          });
        };
      });

      if (parallel) {
        return Promise.all(tasks.map(function (task) {
          return task();
        })).then(function () {
          return values;
        });
      }

      return series(tasks).then(function () {
        return values;
      });
    }
  }, {
    key: '_parse',
    value: function _parse(key, value, original, context, args) {
      var _this2 = this;

      var rule = this._rules[key];

      // When
      //////////////////////////////////////////////////
      if (rule.when) {
        return Promise.resolve(rule.when.call(context, args)).then(function (hit) {
          if (hit) {
            return _this2._real_parse(key, value, rule, original, context, args);
          }

          return value;
        });
      }

      return this._real_parse(key, value, rule, original, context, args);
    }
  }, {
    key: '_real_parse',
    value: function _real_parse(key, value, rule, original, context, args) {
      // Default
      //////////////////////////////////////////////////
      var is_default = !(key in original);
      var result = is_default && rule.default ? rule.default.apply(rule, _toConsumableArray(args))
      // Not default value
      : value;

      return Promise.resolve(result)
      // Validator
      //////////////////////////////////////////////////
      .then(function (value) {
        if (!rule.validate) {
          return value;
        }

        return series.call.apply(series, [context, rule.validate, value].concat(_toConsumableArray(args))).then(function (passes) {
          var pass = passes.every(Boolean);
          if (pass) {
            return value;
          }

          return reject('invalid value "' + value + '" for key "' + key + '"', key, value);
        }, function (error) {
          return reject(error, key, value);
        });
      })
      // Setter
      //////////////////////////////////////////////////
      .then(function (value) {
        if (!rule.set) {
          return value;
        }

        return waterfall.call.apply(waterfall, [context, rule.set, value].concat(_toConsumableArray(args))).then(function (value) {
          return value;
        }, function (error) {
          return reject(error, key, value);
        });
      });
    }
  }]);

  return Skema;
}();

function skema(options) {
  return new Skema(options);
}

skema.Skema = Skema;
skema.Types = Type;
skema.i18n = i18n;

// See "schema design"
function parse_validator(validator) {
  return isFunction(validator) ? validator : isRegExp(validator) ? function (v) {
    return validator.test(v);
  } : false;
}

function define_property(data, key, value, rules) {
  var configurable = rules.configurable,
      enumerable = rules.enumerable,
      writable = rules.writable;


  Object.defineProperty(data, key, {
    configurable: configurable,
    enumerable: enumerable,
    writable: writable,
    value: value
  });
}

function simpleClone(object) {
  return Object.assign(Object.create(null), object);
}